{
    "contents" : "#' @import methods\n#' @importFrom sp Polygon Polygons SpatialPolygons\n#' @importFrom raster raster stack extract predict reclassify\n#' @importFrom SDMTools optim.thresh accuracy\n#' @importFrom mgcv gam gam.control\n#' @importFrom earth earth\n#' @importFrom rpart rpart rpart.control\n#' @importFrom gbm gbm\n#' @importFrom randomForest randomForest\n#' @importFrom dismo maxent\n#' @import nnet nnet\n#' @importFrom e1071 svm\nNULL\n\n##### New generics ##### ----\nsetGeneric('evaluate', function(obj, thresh = 1001, metric = 'AUC') {return(standardGeneric('evaluate'))})\nsetGeneric('get_PA', function(obj) {return(standardGeneric('get_PA'))})\nsetGeneric('PA.select', function(obj, Env, ...) {return(standardGeneric('PA.select'))})\nsetGeneric('data.values', function(obj, Env, na.rm = T) {return(standardGeneric('data.values'))})\nsetGeneric('get_model', function(obj, ...) {return(standardGeneric('get_model'))})\nsetGeneric('project', function(obj, Env, ...) {return(standardGeneric('project'))})\nsetGeneric('evaluate.axes', function(obj, thresh = 1001, Env, axes.metric = 'AUC', ...) {return(standardGeneric('evaluate.axes'))})\nsetGeneric('ensemble', function(x, ..., name = NULL,ensemble.metric = c('AUC'), ensemble.thresh = c(0.75), weight = T, thresh = 1001, uncertainity = T) {return(standardGeneric('ensemble'))})\nsetGeneric('save.enm', function (enm, ...) {return(standardGeneric('save.enm'))})\nsetGeneric('save.stack', function (stack, ...) {return(standardGeneric('save.stack'))})\nsetGeneric('stacking', function(enm, ...) {return(standardGeneric('stacking'))})\n\n##### Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('Niche.Model',\n         representation(name = 'character',\n                        projection = 'Raster',\n                        evaluation = 'data.frame',\n                        variables.importance = 'data.frame',\n                        data = 'data.frame',\n                        parameters = 'data.frame'),\n         prototype(name = character(),\n                   projection = raster(),\n                   evaluation = data.frame(),\n                   variables.importance = data.frame(),\n                   data = data.frame(),\n                   parameters = data.frame()))\n\n# 2 - Methods definition #\nsetMethod('print', 'Niche.Model', function(x, ...) {\n  cat('Object of class :', class(x)[1],'\\n')\n  cat('Name :', x@name, '\\n')\n  cat('Projections : ',names(x@projection),'\\n')\n  print(x@evaluation)\n  print(x@variables.importance)\n  if(inherits(x, 'Ensemble.Niche.Model')) {\n    cat('Uncertinity map :', names(x@uncertainity),'\\n')\n    print(x@algorithm.evaluation)\n    print(x@algorithm.correlation)\n  }\n})\n\n##### Algorithm Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('Algorithm.Niche.Model',\n         contains = 'Niche.Model')\n\n# 2 - Class creation function #\n#' @export\nAlgorithm.Niche.Model <- function(algorithm = 'Algorithm',\n                                  name = character(),\n                                  projection = raster(),\n                                  evaluation = data.frame(),\n                                  variables.importance = data.frame(),\n                                  data = data.frame(),\n                                  parameters = data.frame(matrix(nrow = 1, ncol = 0))) {\n  object.class = paste0(algorithm,'.Niche.Model')\n  return(new(object.class, name = name, projection = projection, evaluation = evaluation, variables.importance = variables.importance, data = data, parameters = parameters))\n}\n\n# 3 - Methods definition #\nsetMethod('get_PA', \"Algorithm.Niche.Model\", function(obj) {return(obj)})\n\nsetMethod('PA.select', \"Algorithm.Niche.Model\", function(obj, Env, PA = NULL, train.frac = 0.7) {\n  if (is.null(PA)) {\n    PA = get_PA(obj)\n    obj@parameters$PA = 'default'\n  } else {\n    obj@parameters$PA = paste0(as.character(PA$nb),'.',as.character(PA$strat))\n  }\n\n  # Mask defining\n  if (PA$strat == '2nd') {\n    cat('   second far selection \\n')\n    circles = list()\n    for (i in 1:length(obj@data$X)) {\n      x = obj@data$X[i]\n      y = obj@data$Y[i]\n      pts = seq(0, 2 * pi, length.out = 100)\n      xy = cbind(x + 2/60 * sin(pts), y + 2/60 * cos(pts))\n      circle = Polygon(xy)\n      circles[i] = circle\n    }\n    sc= SpatialPolygons(list(Polygons(circles, 'Circles')))\n    Mask = mask(Env[[1]], sc)\n  } else {\n    cat('   random selection \\n')\n    Mask = Env[[1]]}\n\n  # Pseudo-Absences selection\n  data.PA = data.frame(matrix(nrow = 0, ncol = 2))\n  names(data.PA) = c('X','Y')\n  if(PA$nb < 100) {nb = PA$nb*PA$nb} else {nb = 1000}\n  while (length(data.PA[,1]) < PA$nb) {\n    X = runif(nb, min = bbox(Mask)[1,1], max = bbox(Mask)[1,2])\n    Y = runif(nb, min = bbox(Mask)[2,1],max = bbox(Mask)[2,2])\n    points = data.frame(X = X, Y = Y)\n    check = extract(Mask, points)\n    points = points[-which(is.na(check)),]\n    data.PA = rbind(data.PA, points)\n  }\n  data.PA = data.PA[1:PA$nb,]\n  data.PA$Presence = 0\n  data.PA$Train = F\n  data.PA$Train[sample.int(length(data.PA$Presence), round(length(data.PA$Presence)*train.frac))] = T\n  obj@data = rbind(obj@data, data.PA)\n\n  return(obj)})\n\nsetMethod('data.values', \"Algorithm.Niche.Model\", function(obj, Env, na.rm = T) {\n  values = data.frame(extract(Env, cbind(obj@data$X, obj@data$Y)))\n\n  # Categorical variables as factor\n  for (i in 1:length(Env@layers)) {\n    if(Env[[i]]@data@isfactor) {\n      col = which(names(values) == Env[[i]]@data@names)\n      values[,col] = as.factor(values[,col])\n      levels(values[,col]) = Env[[i]]@data@attributes[[1]]$ID\n      if(length(Env[[i]]@data@attributes[[1]]$ID) > 100) {\n        warning(paste(names(Env[[i]]), 'as more than 100 levels (', length(Env[[i]]@data@attributes[[1]]$ID), ') are you sure to consider it as a factor ?'))\n        }\n    }\n  }\n\n  # Tables binding\n  obj@data = cbind(obj@data, values)\n\n  # NAs removing\n  if(na.rm) {\n    for (i in 1:length(Env@layers)) {\n      if(length(which(is.na(obj@data[i+3]))) > 0) {obj@data = obj@data[-c(which(is.na(obj@data[i+3]))),]}\n    }\n  }\n\n  return(obj)})\n\nsetMethod('get_model', \"Algorithm.Niche.Model\", function(obj, ....) {return(obj)})\n\nsetMethod('project', \"Algorithm.Niche.Model\",  function(obj, Env, ...) {\n  model = get_model(obj, ...)\n  #proj = predict(Env, model) # Previous classic function that don't take correctly factors variable into account\n  proj = raster::predict(Env, model,\n                         fun = function(model, x){\n                           x= as.data.frame(x)\n                           for (i in 1:length(Env@layers)) {\n                             if(Env[[i]]@data@isfactor) {\n                               x[,i] = as.factor(x[,i])\n                               x[,i] = droplevels(x[,i])\n                               levels(x[,i]) = Env[[i]]@data@attributes[[1]]$ID\n                             }\n                           }\n                           return(predict(model, x))\n                         })\n  # Rescaling projection\n  proj = reclassify(proj, c(-Inf,0,0))\n  proj = proj / proj@data@max\n  names(proj) = \"Projection\"\n  obj@projection = proj\n  return(obj)})\n\nsetMethod('evaluate.axes', \"Algorithm.Niche.Model\", function(obj, thresh = 1001, Env,\n                                                             axes.metric = 'AUC', ...) {\n  obj@parameters$axes.metric = axes.metric\n  obj@variables.importance = data.frame(matrix(nrow = 1, ncol = (length(obj@data)-4)))\n  names(obj@variables.importance) = names(obj@data)[5:length(obj@data)]\n  if (axes.metric == 'Pearson') {\n    data = obj@data[which(!obj@data$Train),]\n    o.predicted.values = extract(obj@projection, data[c('X','Y')]) # original model predicted values\n  }\n\n  for (i in 5:length(obj@data)) {\n    # Get model predictions without one axis reeated for all axis\n    obj.axes = obj\n    obj.axes@data = obj.axes@data[-i]\n    data = obj.axes@data[which(!obj.axes@data$Train),]\n    model = get_model(obj.axes,...)\n    predicted.values = predict(model, data)\n    if (axes.metric != 'Pearson') {\n      threshold = optim.thresh(data$Presence, predicted.values, thresh)\n      threshold = mean(threshold$`max.sensitivity+specificity`)\n      evaluation = accuracy(data$Presence, predicted.values, threshold)\n      obj@variables.importance[1,(i-4)] = obj@evaluation[1,which(names(obj@evaluation) == axes.metric)]  - evaluation[1,which(names(evaluation) == axes.metric)]\n    } else {\n      obj@variables.importance[(i-4)] = cor(predicted.values, o.predicted.values)\n    }\n  }\n\n  # Variable importance normalization (%)\n  if(sum(obj@variables.importance) == 0) {\n    all.null = T\n    for (i in 1:length(obj@variables.importance[1,])) {if(obj@variables.importance[1,i] != 0) {all.null = F}}\n    if (all.null) {\n      obj@variables.importance[1,] = 100 / length(obj@variables.importance)\n    } else {\n      obj@variables.importance = obj@variables.importance * 100\n    }\n  } else {\n    obj@variables.importance = obj@variables.importance / sum(obj@variables.importance) * 100\n  }\n  row.names(obj@variables.importance) = \"Axes.evaluation\"\n  return(obj)})\n\n##### GLM Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('GLM.Niche.Model',\n         contains = 'Algorithm.Niche.Model')\n\n# 2 - Methods definition #\nsetMethod('get_PA', \"GLM.Niche.Model\",\n          function(obj) {\n            PA = list()\n            PA['nb'] = 1000\n            PA['strat'] = 'random'\n            return(PA)})\n\nsetMethod('get_model', \"GLM.Niche.Model\",\n          function(obj, test = 'AIC', epsilon = 1e-08, maxit = 500) {\n            data = obj@data[which(obj@data$Train),]\n            data = data[-c(which(names(data) == 'X'),which(names(data) == 'Y'),which(names(data) == 'Train'))]\n            formula = \"Presence ~\"\n            for (i in 2:length(data)) {\n              var = names(data[i])\n              if (i != 2) {formula = paste(formula,'+',var)} else {formula = paste(formula,var)}\n            }\n            model = glm(formula(formula), data = data, test = test, control = glm.control(epsilon = epsilon, maxit = maxit))\n            for(i in 1:length(data)) {\n              if(is.factor(data[,i])) {\n                model$xlevels[[which(names(model$xlevels) == paste0(names(data)[i]))]] = levels(data[,i])\n              }\n            }\n            return(model)})\n\n##### GAM Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('GAM.Niche.Model',\n         contains = 'Algorithm.Niche.Model')\n\n# 2 - Methods definition #\nsetMethod('get_PA', \"GAM.Niche.Model\",\n          function(obj) {\n            PA = list()\n            PA['nb'] = 1000\n            PA['strat'] = 'random'\n            return(PA)})\n\nsetMethod('get_model', \"GAM.Niche.Model\",\n          function(obj, test = 'AIC', epsilon = 1e-08, maxit = 500) {\n            data = obj@data[which(obj@data$Train),]\n            data = data[-c(which(names(data) == 'X'),which(names(data) == 'Y'),which(names(data) == 'Train'))]\n            formula = \"Presence ~\"\n            for (i in 2:length(data)) {\n              var = names(data[i])\n              if (i != 2) {formula = paste(formula,'+',var)} else {formula = paste(formula,var)}\n              if (!is.factor(data[,i])) {formula = paste0(formula,' + s(',var,')')}\n            }\n            model = gam(formula(formula), data = data, test = test, control = gam.control(epsilon = epsilon, maxit = maxit))\n            #             for(i in 1:length(data)) {\n            #               if(is.factor(data[,i])) {\n            #                 model$xlevels[[which(names(model$xlevels) == names(data)[i])]] = levels(data[,i])\n            #               }\n            #             }\n            return(model)})\n\n##### MARS Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('MARS.Niche.Model',\n         contains = 'Algorithm.Niche.Model')\n\n# 2 - Methods definition #\nsetMethod('get_PA', \"MARS.Niche.Model\",\n          function(obj) {\n            PA = list()\n            PA['nb'] = 100\n            PA['strat'] = 'random'\n            return(PA)})\n\nsetMethod('get_model', \"MARS.Niche.Model\",\n          function(obj, degree = 2) {\n            data = obj@data[which(obj@data$Train),]\n            data = data[-c(which(names(data) == 'X'),which(names(data) == 'Y'),which(names(data) == 'Train'))]\n            model = earth(Presence ~ ., data = data, degree = 2)\n            return(model)})\n\n##### CTA Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('CTA.Niche.Model',\n         contains = 'Algorithm.Niche.Model')\n\n# 2 - Methods definition #\nsetMethod('get_PA', \"CTA.Niche.Model\",\n          function(obj) {\n            PA = list()\n            PA['nb'] = length(obj@data$Presence)\n            PA['strat'] = 'random'\n            return(PA)})\n\nsetMethod('get_model', \"CTA.Niche.Model\",\n          function(obj, final.leave = 1, cv = 3) {\n            data = obj@data[which(obj@data$Train),]\n            data = data[-c(which(names(data) == 'X'),which(names(data) == 'Y'),which(names(data) == 'Train'))]\n            model = rpart(Presence ~ ., data = data, method = 'class',\n                          control = rpart.control(minbucket = final.leave, xval = cv))\n            return(model)})\n\nsetMethod('evaluate.axes', \"CTA.Niche.Model\", function(obj, thresh = 1001, ...) {\n  obj@variables.importance = data.frame(matrix(nrow = 1, ncol = (length(obj@data)-4)))\n  names(obj@variables.importance) = names(obj@data)[5:length(obj@data)]\n  for (i in 5:length(obj@data)) {\n    obj.axes = obj\n    obj.axes@data = obj.axes@data[-i]\n    data = obj.axes@data[which(!obj.axes@data$Train),]\n    model = get_model(obj.axes,...)\n    predicted.values = predict(model,data)[,2]\n    threshold = optim.thresh(data$Presence, predicted.values, thresh)\n    threshold = mean(threshold$`max.sensitivity+specificity`)\n    evaluation = accuracy(data$Presence, predicted.values, threshold)\n    obj@variables.importance[(i-4)] = obj@evaluation$AUC - evaluation$AUC\n  }\n  obj@variables.importance = obj@variables.importance / sum(obj@variables.importance) * 100\n  row.names(obj@variables.importance) = \"Axes.evaluation\"\n  return(obj)})\n\n##### GBM Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('GBM.Niche.Model',\n         contains = 'Algorithm.Niche.Model')\n\n# 2 - Methods definition #\nsetMethod('get_PA', \"GBM.Niche.Model\",\n          function(obj) {\n            PA = list()\n            PA['nb'] = length(obj@data$Presence)\n            PA['strat'] = 'random'\n            return(PA)})\n\nsetMethod('get_model', \"GBM.Niche.Model\",\n          function(obj, trees = 2500, final.leave = 1, cv = 3, thresh.shrink = 1e-03) {\n            data = obj@data[which(obj@data$Train),]\n            data = data[-c(which(names(data) == 'X'),which(names(data) == 'Y'),which(names(data) == 'Train'))]\n            model = gbm(Presence ~ ., data = data,\n                        distribution = 'bernoulli', n.minobsinnode = final.leave,\n                        shrinkage = thresh.shrink, bag.fraction = 0.5,\n                        train.fraction = 1, cv.folds = cv, n.trees = trees)\n            return(model)})\n\n##### RF Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('RF.Niche.Model',\n         contains = 'Algorithm.Niche.Model')\n\n# 2 - Methods definition #\nsetMethod('get_PA', \"RF.Niche.Model\",\n          function(obj) {\n            PA = list()\n            PA['nb'] = length(obj@data$Presence)\n            PA['strat'] = 'random'\n            return(PA)})\n\nsetMethod('get_model', \"RF.Niche.Model\",\n          function(obj, trees = 2500, final.leave = 1) {\n            data = obj@data[which(obj@data$Train),]\n            data = data[-c(which(names(data) == 'X'),which(names(data) == 'Y'),which(names(data) == 'Train'))]\n            model = randomForest(Presence ~ ., data = data, do.classif = TRUE, ntree = trees,\n                                 nodesize = final.leave, maxnodes = NULL)\n            return(model)})\n\n##### MAXENT Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('MAXENT.Niche.Model',\n         contains = 'Algorithm.Niche.Model')\n\n# 2 - Methods definition #\nsetMethod('get_PA', \"MAXENT.Niche.Model\",\n          function(obj) {\n            PA = list()\n            PA['nb'] = 10000\n            PA['strat'] = 'random'\n            return(PA)})\n\nsetMethod('get_model', \"MAXENT.Niche.Model\", function(obj, Env) {\n  factors = c()\n  data = obj@data[which(obj@data$Train),]\n  for(i in 4:length(names(obj@data))) {if(is.factor(obj@data[,i])) {factors = c(factors, names(obj@data)[i])}}\n  model = maxent(x = Env, p = obj@data[which(data$Presence == 1),1:2],\n                 a = obj@data[which(data$Presence == 0),1:2], factors = factors)\n  return(model)})\n\nsetMethod('project', \"MAXENT.Niche.Model\", function(obj, Env, ...) {\n  model = get_model(obj, Env)\n  proj = predict(Env, model)\n  # Rescaling projection\n  proj = reclassify(proj, c(-Inf,0,0))\n  proj = proj / proj@data@max\n  names(proj) = \"Projection\"\n  obj@projection = proj\n  return(obj)})\n\nsetMethod('evaluate.axes', \"MAXENT.Niche.Model\", function(obj, thresh = 1001, Env, ...) {\n  obj@variables.importance = data.frame(matrix(nrow = 1, ncol = (length(obj@data)-4)))\n  names(obj@variables.importance) = names(obj@data)[5:length(obj@data)]\n  for (i in 5:length(obj@data)) {\n    obj.axes = obj\n    obj.axes@data = obj.axes@data[-i]\n    model = get_model(obj.axes, Env[[-(i-4)]])\n    obj.axes@data = obj.axes@data[which(!obj.axes@data$Train),]\n    predicted.values = predict(model, obj.axes@data)\n    threshold = optim.thresh(obj.axes@data$Presence, predicted.values, thresh)\n    threshold = mean(threshold$`max.sensitivity+specificity`)\n    evaluation = accuracy(obj.axes@data$Presence, predicted.values, threshold)\n    obj@variables.importance[(i-4)] = obj@evaluation$AUC - evaluation$AUC\n  }\n  obj@variables.importance = obj@variables.importance / sum(obj@variables.importance) * 100\n  row.names(obj@variables.importance) = \"Axes.evaluation\"\n  return(obj)})\n\n##### ANN Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('ANN.Niche.Model',\n         contains = 'Algorithm.Niche.Model')\n\n# 2 - Methods definition #\nsetMethod('get_PA', \"ANN.Niche.Model\",\n          function(obj) {\n            PA = list()\n            PA['nb'] = length(obj@data$Presence)\n            PA['strat'] = 'random'\n            return(PA)})\n\nsetMethod('get_model', \"ANN.Niche.Model\", function(obj, maxit = 500) {\n  data = obj@data[which(obj@data$Train),]\n  data = data[-c(which(names(data) == 'X'),which(names(data) == 'Y'),which(names(data) == 'Train'))]\n  model = nnet(Presence ~ ., data = data, size = 6, maxit = maxit)\n  return(model)})\n\n##### SVM Niche Model Class ##### -----\n\n# 1 - Class definition #\nsetClass('SVM.Niche.Model',\n         contains = 'Algorithm.Niche.Model')\n\n# 2 - Methods definition #\nsetMethod('get_PA', \"SVM.Niche.Model\", function(obj) {\n  PA = list()\n  PA['nb'] = length(obj@data$Presence)\n  PA['strat'] = 'random'\n  return(PA)})\n\nsetMethod('get_model', \"SVM.Niche.Model\", function(obj, epsilon = 1e-08, cv = 3) {\n  data = obj@data[which(obj@data$Train),]\n  data = data[-c(which(names(data) == 'X'),which(names(data) == 'Y'),which(names(data) == 'Train'))]\n  model = svm(Presence ~ ., data = data, type = 'eps-regression',\n              gamma = 1/(length(data)-1), kernel = 'radial', epsilon = epsilon, cross = cv)\n  return(model)})\n",
    "created" : 1446510145629.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1818087705",
    "id" : "895CDDCD",
    "lastKnownWriteTime" : 1446510152,
    "path" : "~/Documents/R/NumberOne/R/Algorithm.Niche.Model.R",
    "project_path" : "R/Algorithm.Niche.Model.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}